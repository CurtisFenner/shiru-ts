# The Structure of the Shiru Compiler

This document briefly describes the structure of the compiler, explaining the
way the different components fit together.

* `src/shiru/cmd.ts` defines a Node.JS program that can be used to invoke the
  Shiru compiler from the command line.
* `src/shiru/data.ts` defines generic data-structures used by other parts of the
  compiler and interpreter.
* `src/shiru/diagnostics.ts` defines error messages that are generated by the
  compiler and interpreter.
* `src/shiru/dimacs.ts` defines a Node.JS program that can solve CNF files in
  the "DIMACS" format using the built-in SAT-solver.
* `src/shiru/egraph.ts` defines an "egraph" data-structure, which maintains
  equivalence classes between variables, constants, and function applications.
* `src/shiru/grammar.ts` defines the grammar of Shiru.
* `src/shiru/interpreter.ts` defines a library for interpreting compiled Shiru
  programs.
* `src/shiru/ir.ts` defines the "intermediate representation" format for
  compiled programs, that can be interpreted, verified, or compiled to a binary
  target.
* `src/shiru/lexer.ts` defines the lexical (token) grammar of Shiru.
* `src/shiru/library.ts` wraps the compiler pipeline into a small API. This API
  is platform independent, so it can be run in either Node.JS or the web.
* `src/shiru/parser.ts` defines a generic parser-combinator library for parsing
  expression grammars (PEG), which are recursive-descent like.
* `src/shiru/sat.ts` defines a `sat.SATSolver` class which solves the
  _Boolean conjunction-normal-form satisfiability problem_ (CNF-SAT). It uses a
  conflict-drive-clause-learning (CDCL) approach.
* `src/shiru/semantics.ts` performs "semantic analysis", transforming an AST
  produced by the parser into an IR for verification and
  interpretation/compiling.
* `src/shiru/smt.ts` defines a generic satisfiability-modulo-theories (SMT) API.
* `src/shiru/test.ts` defines a Node.JS program that executes the tests in the
  enumerated `*_test.ts` files.
* `src/shiru/uf.ts` defines a `uf.UFTheory` class that implements the
  `smt.SMTSolver` interface for the "uninterpreted functions" theory.
* `src/shiru/verify.ts` defines a verification procedure for certifying that a
  given IR file is totally verified (i.e., it trips no asserts).

The pipeline can be seen in [src/shiru/cmd.ts]:
* lexer
* grammar
    * using parser
* semantics
* verify
    * using uf
        * using smt
            * using sat
        * using egraph
* interpreter 

## The Shiru Intermediate Representation

Shiru's intermediate representation (IR) is defined in `src/ir.ts`. A Shiru
program is represented by the `ir.Program` interface.

The Shiru IR is designed so that it can be type-checked and verified. Within the
IR, functions, variables, and type-definitions are annotated with nominal types,
as well as pre-conditions, post-conditions, and invariants.

The Shiru IR is high-level, but intended to be straightforward to compile to
most targets (modulo the need to generate garbage collection information).
